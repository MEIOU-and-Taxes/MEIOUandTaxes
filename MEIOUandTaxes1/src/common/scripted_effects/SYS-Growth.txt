
# Main function to handle pop birth and death for each province
# Triggered by pulse system and event POP_Growth.001
Growth_GetBirthProv = {
	set_province_flag = POP_ChangedPop # This flags makes the game recalculate a number of pop characteristics after the monthly tick
	
    # Handle Birth and Death for each class with seperate values for birth and death rate
    # There is a exception handling for urban birthing
    Growth_GetBirth = { class = SF rBirth = 1.00 rDeath = 1.05 rural = yes }
    Growth_GetBirth = { class = NM rBirth = 1.00 rDeath = 1.25 rural = yes }
    Growth_GetBirth = { class = RE rBirth = 1.00 rDeath = 1.25 urban = yes }
    Growth_GetBirth = { class = NO rBirth = 0.90 rDeath = 1.50 }
    Growth_GetBirth = { class = BG rBirth = 0.95 rDeath = 1.50 }
    Growth_GetBirth = { class = CL rBirth = 0.90 rDeath = 1.50 }

    # Set how many literates there are
    # 1% of resident population
    if = {
        limit = {
            check_key = { lhs = RE_Total value = 0.001 }
        }
        set_key = { lhs = LT_Total which = RE_Total }
		multiply_key = { lhs = LT_Total value = 0.01 }

        set_key = { lhs = LT_Ratio which = LT_Total }
        multiply_key = { lhs = LT_Ratio value = 100 }
        divide_key = { lhs = LT_Ratio which = RE_Total }
    }
    else = { 
        set_key = { lhs = LT_Total value = 0 }
        set_key = { lhs = LT_Ratio value = 0 }
    }

    # Update overall pop birth key for all classes
    # --> the birth keys are the sum of birth and death
    set_key = { lhs = Class_TotalBirth which = SF_Birth }
    change_key = { lhs = Class_TotalBirth which = NM_Birth }
    change_key = { lhs = Class_TotalBirth which = RE_Birth }
    change_key = { lhs = Class_TotalBirth which = NO_Birth }
    change_key = { lhs = Class_TotalBirth which = BG_Birth }
    change_key = { lhs = Class_TotalBirth which = CL_Birth }
}

# Handle birth and death calculation for each class
# Inputs:
# $class$ = SF | NM | RE | NO | BG | CL
# rBirth = decimal number (multiplier) - Multiplier on birth rate
# rDeath = decimal number (multiplier) - Multiplier on death rate
Growth_GetBirth = {
    if = {
        limit = {
            check_key = { lhs = $class$_Total value = 0.001 } # If there are pops do calc
        }
        ### CASE SWITCH
        # CASE $class$ LifeC Fulfilment >= Growth_PointNeutralFill%
		if = {
			limit = {
				check_key = { lhs = $class$_FillLifeC value = 0.75 } # `Growth_PointNeutralFill~value`
			}
            # Tmp_0 = LifeCFullfilment - Growth_PointNeutralFill
            # Tmp_1 = LifeCFullfilment
			set_key = { lhs = Tmp_0 which = $class$_FillLifeC }
            if = {
                limit = {
                    check_key = { lhs = $class$_FillLifeC value = 2.33 } # `Growth_PointMaxFulfill~value`
                }
                set_key = { lhs = Tmp_0 value = 2.33 } # `Growth_PointMaxFulfill~value`
            }
			set_key = { lhs = Tmp_1 which = Tmp_0 }
			subtract_key = { lhs = Tmp_0 value = 0.75 } # `Growth_PointNeutralFill~value`
			
			# Birth Rate formula:
			#  (LifeCFulfillment - Growth_PointNeutralFill) * Growth_MultPositiveFill
			# (--------------------------------------------------------------------- * (LifeCFulfillment - Growth_PointNeutralFill) + 1) * rBirth
			#                             LifeCFulfillment
			
			set_key = { lhs = Growth_Birth which = Tmp_0 }
			multiply_key = { lhs = Growth_Birth value = 1.0 }   # `Growth_MultPositiveFill~value` ## TOO STRONK
			divide_key = { lhs = Growth_Birth which = Tmp_1 }
			multiply_key = { lhs = Growth_Birth which = Tmp_0 }
			change_key = { lhs = Growth_Birth value = 1 }
			multiply_key = { lhs = Growth_Birth value = $rBirth$ }
			
			## Modifer on pop growth based on usage of land / fisheries in the province
			# The more unused land / fisheries in % the higher the bonus to birth rate due to abundand ressoure and opportunity
            # Applies by the condition rural (currently used for peasants and nomads)
			[[rural]
				set_key = { lhs = Tmp_2 value = 0 }
				set_key = { lhs = Tmp_3 value = 0 }

                ### Calculate multiplier by agricultural filling
				if = {
					limit = {
						has_province_flag = Building_AgricultureHas
						check_key = { lhs = Building_AgricultureFill value = 0.001 }
					}
					set_key = { lhs = Tmp_2 which = Building_AgricultureFill }
                    set_key = { lhs = Tmp_4 which = Tmp_2 }

					change_key = { lhs = Tmp_2 value = 0.30 }   # `Growth_BaseDividendBirthFromEmptyAgriculture~value`
                    multiply_key = { lhs = Tmp_4 value = 1.30 } # `Growth_MultDivisorBirthFromEmptyAgriculture~value`
                    change_key = { lhs = Tmp_4 value = 0.1 }   # `Growth_BaseDivisorBirthFromEmptyAgriculture~value`
					divide_key = { lhs = Tmp_2 which = Tmp_4 }
				}
                ### Calculate multiplier by fishery filling
				if = {
					limit = {
						has_province_flag = Building_FisheryHas
						check_key = { lhs = Building_FisheryFill value = 0.001 }
					}

					set_key = { lhs = Tmp_3 which = Building_FisheryFill }
                    set_key = { lhs = Tmp_4 which = Tmp_3 }

					change_key = { lhs = Tmp_3 value = 0.30 }   # `Growth_BaseDividendBirthFromEmptyFishery~value`
                    multiply_key = { lhs = Tmp_4 value = 1.30 } # `Growth_MultDivisorBirthFromEmptyFishery~value`
                    change_key = { lhs = Tmp_4 value = 0.1 }   # `Growth_BaseDivisorBirthFromEmptyFishery~value`
					divide_key = { lhs = Tmp_3 which = Tmp_4 }
				}

				### Weight Fishery and Agriculture multiplier by some factor
				if = {
					limit = {
						check_key = { lhs = Tmp_2 value = 0.001 }
						check_key = { lhs = Tmp_3 value = 0.001 }
					}
					multiply_key = { lhs = Tmp_2 value = 0.8 }  # `Growth_ScaleBirthFromEmptyAgriculture~value`
					multiply_key = { lhs = Tmp_3 value = 0.2 }  # `Growth_ScaleBirthFromEmptyFishery~value`

					change_key = { lhs = Tmp_2 which = Tmp_3 }
				}

				### Check modifier constraints
				if = {
					limit = {
						NOT = { is_key_equal = { lhs = Tmp_2 value = 0 } }
					}

					if = {
						limit = {
							check_key = { lhs = Tmp_2 value = 1.5 }            # `Growth_MaxBirthFromEmpty~value`
						}
						set_key = { lhs = Tmp_2 value = 1.5 }                  # `Growth_MaxBirthFromEmpty~value`
					}

					else_if = {
						limit = {
							NOT = { check_key = { lhs = Tmp_2 value = 0.95 } }  # `Growth_MinBirthFromEmpty~value`
						}
						set_key = { lhs = Tmp_2 value = 0.95 }                  # `Growth_MinBirthFromEmpty~value`
					}

					multiply_key = { lhs = Growth_Birth which = Tmp_2 }
				}
			]


			set_key = { lhs = Growth_Death value = $rDeath$ }
            
            # Special Handling for Urban death rates
			[[urban]
				if = {
					limit = {
						always = $urban$
					}
					
                    Infra_GetAmenities_Cap = { return = Tmp_0 } # Get cap of amenities after which higher death rates are applied
                    
                    ## If above the cap, recalculate birth rate for this case
					if = {
						limit = {
							check_key = { lhs = RE_Total which = Tmp_0 }
						}

                        # Death rate formula:
                        # (Residents - AmenitiesCap)
                        # -------------------------   * rDeath * Growth_DeathMultFromLowAmenities + rDeath
                        #         Residents
						set_key = { lhs = Growth_Death which = RE_Total }
						subtract_key = { lhs = Growth_Death which = Tmp_0 }
						divide_key = { lhs = Growth_Death which = RE_Total }
						multiply_key = { lhs = Growth_Death value = $rDeath$ }
						multiply_key = { lhs = Growth_Death value = 2.0 } # `Growth_DeathMultFromLowAmenities~value`
						change_key = { lhs = Growth_Death value = $rDeath$ }
					}
				}
			]
		}
		else = { # CASE $class$ LifeC Fulfilment < Growth_PointNeutralFill%
			
            # Birth rate formula: LifeCFulfillment * 0.782 + 0.414
            set_key = { lhs = Growth_Birth which = $class$_FillLifeC }
			multiply_key = { lhs = Growth_Birth value = 0.782 } # `Growth_MultNegativeFill~value`
			change_key = { lhs = Growth_Birth value = 0.414 }   # `Growth_BaseNegativeFill~value`
			
			set_key = { lhs = Growth_Death value = $rDeath$ }

            # Special Handling for Urban death rates
			[[urban]
				if = {
					limit = {
						always = $urban$
					}

					Infra_GetAmenities_Cap = { return = Tmp_0 } # Get cap of amenities after which higher death rates are applied

                    if = {
						limit = {
							check_key = { lhs = RE_Total which = Tmp_0 }
						}
					    
                        # Death rate formula:
                        # (Residents - AmenitiesCap)
                        # -------------------------   * rDeath * Growth_DeathMultFromLowAmenities + rDeath
                        #         Residents
						set_key = { lhs = Growth_Death which = RE_Total }
						subtract_key = { lhs = Growth_Death which = Tmp_0 }
						divide_key = { lhs = Growth_Death which = RE_Total }
						multiply_key = { lhs = Growth_Death value = $rDeath$ }
						multiply_key = { lhs = Growth_Death value = 2.0 } # `Growth_DeathMultFromLowAmenities~value`
						change_key = { lhs = Growth_Death value = $rDeath$ }
					}
				}
			]

			divide_key = { lhs = Growth_Death which = Growth_Birth } # Get birth death rate ratio

			multiply_key = { lhs = Growth_Birth value = $rBirth$ } # Apply hardcoded modifier on birth rate
		}

        # Apply API modifiers to Birth and Death rates
		multiply_key = { lhs = Growth_Birth which = Modi_Birth }
		multiply_key = { lhs = Growth_Birth which = Modi_Birth$class$ }
		multiply_key = { lhs = Growth_Death which = Modi_Death }

        # Subtract Birth and Death Rate
		set_key = { lhs = $class$_Birth which = Growth_Birth }
		subtract_key = { lhs = $class$_Birth which = Growth_Death }

        # Multiply combined birth/death rate with class total to get absolute pop change
		multiply_key = { lhs = $class$_Birth which = $class$_Total }
		multiply_key = { lhs = $class$_Birth value = 0.01 }  # `Growth_GrowthSpeed~value`

        # Apply change to actual total pop key
		change_key = { lhs = $class$_Total which = $class$_Birth }

        # Exception handling for negative pop values
		if = {
			limit = {
				NOT = {
					check_key = { lhs = $class$_Total value = 0 }
				}
			}
			set_key = { lhs = $class$_Total value = 0 }
		}

		set_key = { lhs = Growth_Birth value = 0 }
		set_key = { lhs = Growth_Death value = 0 }
	}
	else = { # Exception handling for no local pop of $class$
		set_key = { lhs = $class$_Birth value = 0 }
		set_key = { lhs = $class$_Total value = 0 }
	}
}

# Main function to handle migration for all provinces and countries
# Triggered by pulse system and event POP_Growth.002
Growth_DoMove = {
    # Prepare migration in all valid provinces
    every_province = {
        limit = {
            isValidProv = yes
        }
        ### Calculate migratory pressure for each class based on labor (price) type
        Growth_SetPressure = { class = SF labor = R peasant=yes }
        Growth_SetPressure = { class = NM labor = NM nomad=yes }
        Growth_SetPressure = { class = RE labor = UL urban=yes }

		### This effectively disables elite migration
        #Growth_SetPressure = { class = NO labor = NO }
        #Growth_SetPressure = { class = BG labor = BG burgher=yes }
        #Growth_SetPressure = { class = CL labor = CL }
		set_key = { lhs = Growth_PressureNO value = 0 }
		set_key = { lhs = Growth_PressureBG value = 0 }
		set_key = { lhs = Growth_PressureCL value = 0 }
        
        ### Get multiplication of class pop numbers and calculated outward pressure % --> potential pressure
        set_key = { lhs = Tmp_2 which = SF_Total }
        set_key = { lhs = Tmp_3 which = NM_Total }
        set_key = { lhs = Tmp_4 which = RE_Total }
        set_key = { lhs = Tmp_5 which = NO_Total }
        set_key = { lhs = Tmp_6 which = BG_Total }
        set_key = { lhs = Tmp_7 which = CL_Total }

        multiply_key = { lhs = Tmp_2 which = Growth_PressureSF }
        multiply_key = { lhs = Tmp_3 which = Growth_PressureNM }
        multiply_key = { lhs = Tmp_4 which = Growth_PressureRE }
        multiply_key = { lhs = Tmp_5 which = Growth_PressureNO }
        multiply_key = { lhs = Tmp_6 which = Growth_PressureBG }
        multiply_key = { lhs = Tmp_7 which = Growth_PressureCL }

		### Apply modifier on migration based on peasant freedom and tenacy reform
        #
        # Tenacy Reform Level     Peasant Freedom
        # ------------------- *  ----------------- + 0.1
        #          4                    100
        #
        # Constraints: [0.1, 1]
		owner = { 
		    set_key = { lhs = Tmp_8 which = Rights_NOTen }
		}

		set_key = { lhs = Tmp_8 which = owner }
		change_key = { lhs = Tmp_8 value = 3 } # move the reform key from the scale [-2,1] to [1,4]
		divide_key = { lhs = Tmp_8 value = 4 }

		set_key = { lhs = Tmp_9 which = SF_Freedom }

		divide_key = { lhs = Tmp_9 value = 100 } # move peasant freedom on a scale between [0,1]

		multiply_key = { lhs = Tmp_8 which = Tmp_9 } # calculate multiplier

		change_key = { lhs = Tmp_8 value = 0.1 }
		if = {
		    limit = {
		        check_key = { lhs = Tmp_8 value = 1.001 }
		    }
		    set_key = { lhs = Tmp_8 value = 1 }
		}
		else_if = {
		    limit = {
		        NOT = { check_key = { lhs = Tmp_8 value = 0.1 } }
		    }
		    set_key = { lhs = Tmp_8 value = 0.1 }
		}

		multiply_key = { lhs = Tmp_2 which = Tmp_8 } # apply multiplier to actual migrants pool

		# Tmp_0 = total sum of possible migrants
        set_key = { lhs = Tmp_0 which = Tmp_2 }
        change_key = { lhs = Tmp_0 which = Tmp_3 }
        change_key = { lhs = Tmp_0 which = Tmp_4 }
        change_key = { lhs = Tmp_0 which = Tmp_5 }
        change_key = { lhs = Tmp_0 which = Tmp_6 }
        change_key = { lhs = Tmp_0 which = Tmp_7 }

        # Tmp_1 = All classes - NO - CL - BG
        set_key = { lhs = Tmp_1 which = SF_Total }
		multiply_key = { lhs = Tmp_1 which = Tmp_8 } # deduct peasant freedom effect from peasant total
        change_key = { lhs = Tmp_1 which = NM_Total }
        change_key = { lhs = Tmp_1 which = RE_Total }
        #change_key = { lhs = Tmp_1 which = BG_Total }
        #change_key = { lhs = Tmp_1 which = NO_Total }
        #change_key = { lhs = Tmp_1 which = CL_Total }
        
        # Reset existing migration variables of last year
        set_key = { lhs = SF_In value = 0 }
        set_key = { lhs = NM_In value = 0 }
        set_key = { lhs = RE_In value = 0 }
        set_key = { lhs = NO_In value = 0 }
        set_key = { lhs = BG_In value = 0 }
        set_key = { lhs = CL_In value = 0 }

        set_key = { lhs = SF_Out value = 0 }
        set_key = { lhs = NM_Out value = 0 }
        set_key = { lhs = RE_Out value = 0 }
        set_key = { lhs = NO_Out value = 0 }
        set_key = { lhs = BG_Out value = 0 }
        set_key = { lhs = CL_Out value = 0 }
    }

    # Flag migration zone for each independent country + subjects (4 subject lvls at max) with Growth_Zone province flag
    every_country = {
        limit = {
            isValidCountry = yes
			is_free_or_tributary_trigger = yes
        }
        every_owned_province = {
            set_province_flag = Growth_Zone
        }

        every_subject_country = {
            limit = {
                isValidCountry = yes
				is_subject_other_than_tributary_trigger = yes
            }
            every_owned_province = {
                set_province_flag = Growth_Zone
            }

            every_subject_country = {
                limit = {
                    isValidCountry = yes
					is_subject_other_than_tributary_trigger = yes
                }
                every_owned_province = {
                    set_province_flag = Growth_Zone
                }

                every_subject_country = {
                    limit = {
                        isValidCountry = yes
						is_subject_other_than_tributary_trigger = yes
                    }
                    every_owned_province = {
                        set_province_flag = Growth_Zone
                    }

                    every_subject_country = {
                        limit = {
                            isValidCountry = yes
							is_subject_other_than_tributary_trigger = yes
                        }
                        every_owned_province = {
                            set_province_flag = Growth_Zone
                        }
                    }
                }
            }
        }
	    
        # Reset keys
		set_key = { lhs = Tmp_0 value = 0 }
        set_key = { lhs = Tmp_1 value = 0 }

		# Sum up per growth zone 
		# Tmp_0 = total sum of possible migrants
		# Tmp_1 = All classes - NO - CL - BG
        every_province = {
            limit = {
				has_province_flag = Growth_Zone
            }
            PREV = {
                change_key = { lhs = Tmp_0 which = PREV }
                change_key = { lhs = Tmp_1 which = PREV }
            }
        }

		# Public_Tmp1 = PossibleMigrants in Growth Zone / Total pops in growth zone
        if = {
            limit = {
                check_key = { lhs = Tmp_0 value = 0.001 }
                check_key = { lhs = Tmp_1 value = 0.001 }
            }
            set_key = { lhs = Public_Tmp1 which = Tmp_0 }
            divide_key = { lhs = Public_Tmp1 which = Tmp_1 }

            # If there are possible migrants calculate
            if = {
                limit = {
                    check_key = { lhs = Public_Tmp1 value = 0.001 }
                }
                set_key = { lhs = Public_Tmp2 value = 0 }
                set_key = { lhs = Public_Tmp3 value = 0 }
                set_key = { lhs = Public_Tmp4 value = 0 }
                set_key = { lhs = Public_Tmp5 value = 0 }

                every_province = {
                    limit = {
                        has_province_flag = Growth_Zone
                    }
                    set_key = { lhs = Public_Tmp1 which = PREV } # get possible migrant % of total pops
                    set_key = { lhs = Public_Tmp2 value = 0 }
                    set_key = { lhs = Public_Tmp3 value = 0 }
                    set_key = { lhs = Public_Tmp4 value = 0 }
                    set_key = { lhs = Public_Tmp5 value = 0 }

                    # Calculate migration on province level
                    # how many pops want to go in vs. out
                    Growth_DoMove_HandleLocalMigration = { class = SF tmp = 2 freedom = Tmp_8 }
                    Growth_DoMove_HandleLocalMigration = { class = NM tmp = 3 }
                    Growth_DoMove_HandleLocalMigration = { class = RE tmp = 4 }
                    Growth_DoMove_HandleLocalMigration = { class = NO tmp = 5 }
                    Growth_DoMove_HandleLocalMigration = { class = BG tmp = 6 factor = 2 }
                    Growth_DoMove_HandleLocalMigration = { class = CL tmp = 7 }

                    PREV = { # sum up all values in growth zone
                        change_key = { lhs = Public_Tmp2 which = PREV } # Total inward migration
                        change_key = { lhs = Public_Tmp3 which = PREV } # Total outward migration
                        change_key = { lhs = Public_Tmp4 which = PREV } # Total inward migration
                        change_key = { lhs = Public_Tmp5 which = PREV } # Total outward migration
                    }
                }

                # cap actual migration to smaller of outward/inward
                if = {
                    limit = {
                        check_key = { lhs = Public_Tmp4 which = Public_Tmp5 }
                    }
                    set_key = { lhs = Public_Tmp4 which = Public_Tmp5 }
                }

                # 
                every_province = {
                    limit = {
                        has_province_flag = Growth_Zone
                    }
                    # Get previous calculation results
                    set_key = { lhs = Public_Tmp2 which = PREV } # Total outward migration
                    set_key = { lhs = Public_Tmp3 which = PREV } # Total inward migration
                    set_key = { lhs = Public_Tmp4 which = PREV } # Total actual migration, smaller of outward/inward

                    # Distribute migration on provinces
                    Growth_DoMove_DistributeMigration = { class = SF tmp = 2 }
                    Growth_DoMove_DistributeMigration = { class = NM tmp = 3 }
                    Growth_DoMove_DistributeMigration = { class = RE tmp = 4 }
                    Growth_DoMove_DistributeMigration = { class = NO tmp = 5 }
                    Growth_DoMove_DistributeMigration = { class = BG tmp = 6 }
                    Growth_DoMove_DistributeMigration = { class = CL tmp = 7 }

                    # Clear calculation data
                    clr_province_flag = Growth_Zone 

                    set_key = { lhs = Public_Tmp1 value = 0 }
                    set_key = { lhs = Public_Tmp2 value = 0 }
                    set_key = { lhs = Public_Tmp3 value = 0 }
                    set_key = { lhs = Public_Tmp4 value = 0 }
                    set_key = { lhs = Public_Tmp5 value = 0 }
                    set_key = { lhs = Public_Tmp9 value = 0 }
                }

                # Clear calculation data
                set_key = { lhs = Public_Tmp2 value = 0 }
                set_key = { lhs = Public_Tmp3 value = 0 }
                set_key = { lhs = Public_Tmp4 value = 0 }
                set_key = { lhs = Public_Tmp5 value = 0 }
            }
        }

        set_key = { lhs = Tmp_0 value = 0 }
        set_key = { lhs = Tmp_1 value = 0 }

        set_key = { lhs = Public_Tmp1 value = 0 }
    }

	#### Migration Zone Mechanics:
	# The below function repeat the migration calculation for specified regional zones, classes, cultures, etc.
	# This is meant to represent a number of historical situations

    #Holy Roman Empire
    Growth_ZoneHelper = { scope=europe HRE=yes SF=yes RE=yes }
    #Italian States
    Growth_ZoneHelper = { scope=italy_superregion cultg=latin SF=yes RE=yes }
    #Maya
    Growth_ZoneHelper = { scope=central_america_region SF=yes RE=yes NM=yes }
    #Ireland
    Growth_ZoneHelper = { scope=ireland_region SF=yes RE=yes }
    #Manchuria
    Growth_ZoneHelper = { scope=asia flag=Manchu_Zone SF=yes RE=yes NM=yes }
    #Western Steppe
    Growth_ZoneHelper = { scope=steppes_group flag=WestSteppe_Zone NM=yes }
    #Eastern Steppe
    Growth_ZoneHelper = { scope=steppes_group flag=EastSteppe_Zone NM=yes }
    #Arabian Steppe
    Growth_ZoneHelper = { scope=arabian_steppes_group NM=yes }
    #Saharan Steppe
    Growth_ZoneHelper = { scope=saharan_steppes_group NM=yes }
    #Anatolian Nomads
    Growth_ZoneHelper = { scope=anatolia_steppes_group NM=yes }
    if = {
        limit = {
            BYZ = { has_country_flag = BYZ_MigrationIn }
        }
        Growth_ZoneHelper = { scope=bosphorous_strait_group cultg=greek_group SF=yes RE=yes NM=yes }
    }

	# Sum up all changes in total pops, migration etc. per province and set flag that pop was updated
    every_province = {
        limit = {
            isValidProv = yes
        }
		set_province_flag = POP_ChangedPop
		
        set_key = { lhs = Class_TotalIn which = SF_In }
        change_key = { lhs = Class_TotalIn which = NM_In }
        change_key = { lhs = Class_TotalIn which = RE_In }
        change_key = { lhs = Class_TotalIn which = NO_In }
        change_key = { lhs = Class_TotalIn which = BG_In }
        change_key = { lhs = Class_TotalIn which = CL_In }

        set_key = { lhs = Class_TotalOut which = SF_Out }
        change_key = { lhs = Class_TotalOut which = NM_Out }
        change_key = { lhs = Class_TotalOut which = RE_Out }
        change_key = { lhs = Class_TotalOut which = NO_Out }
        change_key = { lhs = Class_TotalOut which = BG_Out }
        change_key = { lhs = Class_TotalOut which = CL_Out }

        change_key = { lhs = SF_Total which = SF_In }
        change_key = { lhs = NM_Total which = NM_In }
        change_key = { lhs = RE_Total which = RE_In }
        change_key = { lhs = NO_Total which = NO_In }
        change_key = { lhs = BG_Total which = BG_In }
        change_key = { lhs = CL_Total which = CL_In }

        subtract_key = { lhs = SF_Total which = SF_Out }
        subtract_key = { lhs = NM_Total which = NM_Out }
        subtract_key = { lhs = RE_Total which = RE_Out }
        subtract_key = { lhs = NO_Total which = NO_Out }
        subtract_key = { lhs = BG_Total which = BG_Out }
        subtract_key = { lhs = CL_Total which = CL_Out }

        set_key = { lhs = Tmp_0 value = 0 }
        set_key = { lhs = Tmp_1 value = 0 }
        set_key = { lhs = Tmp_2 value = 0 }
        set_key = { lhs = Tmp_3 value = 0 }
        set_key = { lhs = Tmp_4 value = 0 }
        set_key = { lhs = Tmp_5 value = 0 }
        set_key = { lhs = Tmp_6 value = 0 }
        set_key = { lhs = Tmp_7 value = 0 }
    }
}

### Inputs:
# $class$ = SF | NM | RE | NO | BG | CL
# $tmp$ = tmp key number to use for calculation
# $factor$ = balancing factor to reduce migration speed
## Keys:
# Growth_Pressure$class$ = Local outward migratory pressure in % of the population
# Public_Tmp1 = (PossibleMigrants in Growth Zone / Total pops in growth zone)
## Conditionals:
# $zone$ = enables 50% multiplier on amount of possible migration
### Outputs:
# Public_Tmp2, Public_Tmp4 = Outward migration absolute
# Public_Tmp3, Public_Tmp5 = Inward migration absolute
Growth_DoMove_HandleLocalMigration = {
    if = {
        limit = {
            check_key = { lhs = Growth_Pressure$class$ value = 0.001 } # If pressure per $class$ greater 0.001 in this province
        }
		
		# Public_Tmp9 = Migratory pressure of class / (PossibleMigrants in Growth Zone / Total pops in growth zone)
        set_key = { lhs = Public_Tmp9 which = Growth_Pressure$class$ }
        divide_key = { lhs = Public_Tmp9 which = Public_Tmp1 }
        
		# Ceiling at factor of 3
        if = {
            limit = {
                check_key = { lhs = Public_Tmp9 value = 3 }
            }
            set_key = { lhs = Public_Tmp9 value = 3 }
        }

        subtract_key = { lhs = Public_Tmp9 value = 1 }
		
		## Case: Migratory outward pressured pops % of province >= Possible Migrants in % of zone pops --> outward migration
        if = {
            limit = {
                check_key = { lhs = Growth_Pressure$class$ which = Public_Tmp1 }
            }

			#       $class$_Total * (Pressure/Possible Migrants%) [[freedom] * Freedom modifier on migration] [[zone] * 0.5]
			#       ------------------------------------------------------------
			#                                80
			#                     ------------------------
			#                          [[factor] factor]
			set_key = { lhs = Tmp_$tmp$ which = $class$_Total }
			[[zone]multiply_key = { lhs = Tmp_$tmp$ value = 0.5 }]
			[[freedom] multiply_key = { lhs = Tmp_$tmp$ which = $freedom$ }]
			multiply_key = { lhs = Tmp_$tmp$ which = Public_Tmp9 }
			divide_key = { lhs = Tmp_$tmp$ value = 80 }
			[[factor] divide_key = { lhs = Tmp_$tmp$ value = $factor$ } ]
			
			# Store results
            change_key = { lhs = Public_Tmp2 which = Tmp_$tmp$ }
            change_key = { lhs = Public_Tmp4 which = Tmp_$tmp$ }
        }
        else = { # Migratory outward pressured pops % of province < Possible Migrants in % of zone pops --> inward migration
			
			#       ($class$_Total * [[zone] * 0.5] + 10)* (Pressure/Possible Migrants%) 
			#       ------------------------------------------------------------
			#                                -40
			#                     ------------------------
			#                          [[factor] factor]
			set_key = { lhs = Tmp_$tmp$ which = $class$_Total }
			[[zone]multiply_key = { lhs = Tmp_$tmp$ value = 0.5 }]
			[[freedom] multiply_key = { lhs = Tmp_$tmp$ which = $freedom$ }]
			change_key = { lhs = Tmp_$tmp$ value = 10 }
			multiply_key = { lhs = Tmp_$tmp$ which = Public_Tmp9 }
			divide_key = { lhs = Tmp_$tmp$ value = -40 }
			[[factor] divide_key = { lhs = Tmp_$tmp$ value = $factor$ } ]
			
			# Store results
			change_key = { lhs = Public_Tmp3 which = Tmp_$tmp$ }
			change_key = { lhs = Public_Tmp5 which = Tmp_$tmp$ }
		}
    }
}

# This function distributes the migration happening on the provinces inside the growth zone
### Inputs:
# $class$ = SF | NM | RE | NO | BG | CL
# $tmp$ = tmp key number to use for calculation
#
## Keys:
# Growth_Pressure$class$ = Local outward migratory pressure in % of the population
# Public_Tmp1 = (PossibleMigrants in Growth Zone / Total pops in growth zone)
# Public_Tmp2 = Total per Growth Zone Outward migration absolute
# Public_Tmp3 = Total per Growth Zone Inward migration absolute
# Public_Tmp4 = Total per Growth Zone migration absolute (smaller of Public_Tmp2/Public_Tmp3)
#
### Outputs:
# $class$_In | $class$_Out = Migration for this province (mutually exclusive, either in or out per class)
Growth_DoMove_DistributeMigration = {
    if = {
        limit = {
            check_key = { lhs = Growth_Pressure$class$ value = 0.001 } #if province has pressure
        }
        if = {
            limit = {
                check_key = { lhs = Growth_Pressure$class$ which = Public_Tmp1 } # local pressure >= possible migrants %
            }
            if = {
                limit = {
                    check_key = { lhs = Public_Tmp2 value = 0.001 } # total outward migration > 0
                }

				### Outward migration in province
				#     local migration 
				# ----------------------  * total outward migration
				# total outward migration
                set_key = { lhs = Public_Tmp9 which = Tmp_$tmp$ } # Result of local migration calc
				multiply_key = { lhs = Public_Tmp9 which = Public_Tmp4 }
                divide_key = { lhs = Public_Tmp9 which = Public_Tmp2 }

                change_key = { lhs = $class$_Out which = Public_Tmp9 }
            }
        }
        else_if = {
            limit = {
                check_key = { lhs = Public_Tmp3 value = 0.001 } # total inward migration > 0
            }

			### Inward migration in province
			#     local migration 
			# ----------------------  * total inward migration
			# total inward migration
            set_key = { lhs = Public_Tmp9 which = Tmp_$tmp$ }
			multiply_key = { lhs = Public_Tmp9 which = Public_Tmp4 }
            divide_key = { lhs = Public_Tmp9 which = Public_Tmp3 }
            
            change_key = { lhs = $class$_In which = Public_Tmp9 }
        }
    }
}

# This function sets the migratory pressure for each class and labor type in percent
# Inputs:
# $class$ = SF | NM | RE | NO | BG | CL
# $labor$ = R | NM | UL | NO | NO | BG | CL (R = Rural, UL = Urban labor)
# Conditionals:
# peasants | nomads | urban | burgher = yes --> enable special conditions to allow migration
#
# Output: Growth_Pressure$class$ - Constraints [0.02, 0.10]
Growth_SetPressure = {
    # Generate preasure if pops exist or labor price in province is > 1
    if = {
        limit = {
            OR = {
				check_key = { lhs = $class$_Total value = 0.001 }
				check_key = { lhs = Class_P$labor$ value = 1.001 }
			}
			[[urban] # only allow resident migration if there is a city
			always = $urban$
			has_province_flag = City_Present
			]
			[[burgher] # only allow burgher migration if there is a commerce industry
			always = $burgher$
			has_province_flag = Industry_32Present
			]
			[[peasant] # only allow peasant migration if there are rural industries
			always = $peasant$
			has_province_flag = Rural_Present
			]
			[[nomad] # only allow nomad migration if there is nomad industry
			always = $nomad$
			has_province_flag = Industry_8Present
			]
        }
		
        ### Calculate migration (outward?) pressure per class in %:
        #                    40
        #      ------------------------------ 
        #        Province Labor Cost per Type
        # ---------------------------------------
        #                   400
        set_key = { lhs = Growth_Pressure$class$ value = 40 }
        divide_key = { lhs = Growth_Pressure$class$ which = Class_P$labor$ }
        divide_key = { lhs = Growth_Pressure$class$ value = 400 }
		

		[[urban]
			if = {
				limit = { 
					always = $urban$
					has_province_flag = City_Present
				}
                ### Apply amenities cap multiplier on migration into cities
                # Constraints: [Growth_MinBaseMigrationPressureEmptyAmenities, Growth_MaxMigrationPressureEmptyAmenities]
                Infra_GetAmenities_Cap = { return = Tmp_0 }

                set_key = { lhs = Tmp_1 which = $class$_Total }
                divide_key = { lhs = Tmp_1 which = Tmp_0 }

                if = {
                    limit = {
                        check_key = { lhs = Tmp_1 value = 2 }
                    }
                    set_key = { lhs = Tmp_1 value = 1.25 }      # `Growth_MaxMigrationPressureEmptyAmenities~value`
                }
                else_if = {
                    limit = {
                        check_key = { lhs = Tmp_1 value = 1 }
                    }
                    multiply_key = { lhs = Tmp_1 value = 0.25 }
                    change_key = { lhs = Tmp_1 value = 0.75 }
                }
                else = {
                    multiply_key = { lhs = Tmp_1 value = 0.2 }  # `Growth_MinMultMigrationPressureEmptyAmenities~value`
                    change_key = { lhs = Tmp_1 value = 0.8 }    # `Growth_MinBaseMigrationPressureEmptyAmenities~value`
                }

				multiply_key = { lhs = Growth_Pressure$class$ which = Tmp_1 }

                ### Apply multiplier based on city size
                # Min: Growth_BaseDividendMigrationPressureCitySize / Growth_BaseDivisorMigrationPressureCitySize
                # Max: Growth_MultDividendMigrationPressureCitySize / Growth_MultDivisorMigrationPressureCitySize
                set_key = { lhs = Tmp_0 which = $class$_Total }
                set_key = { lhs = Tmp_1 which = $class$_Total }
                multiply_key = { lhs = Tmp_0 value = 2 }        # `Growth_MultDividendMigrationPressureCitySize~value`
                multiply_key = { lhs = Tmp_1 value = 1.25 }     # `Growth_MultDivisorMigrationPressureCitySize~value`
                change_key = { lhs = Tmp_0 value = 60 }         # `Growth_BaseDividendMigrationPressureCitySize~value`
                change_key = { lhs = Tmp_1 value = 120 }        # `Growth_BaseDivisorMigrationPressureCitySize~value`
                divide_key = { lhs = Tmp_0 which = Tmp_1 }

				multiply_key = { lhs = Growth_Pressure$class$ which = Tmp_0 }
			}
		]

        # Apply API effects on pressure
		multiply_key = { lhs = Growth_Pressure$class$ which = Modi_PressureMulti$class$ }
		change_key = { lhs = Growth_Pressure$class$ which = Modi_PressureAdd$class$ }
		
		if = {
			limit = {
				NOT = {
					check_key = { lhs = Growth_Pressure$class$ value = 0.002 }
				}
			}
			set_key = { lhs = Growth_Pressure$class$ value = 0.002 }
		}
		if = {
			limit = {
				check_key = { lhs = Growth_Pressure$class$ value = 0.1 }
			}
			set_key = { lhs = Growth_Pressure$class$ value = 0.1 }
		}
    }
    else = {
        set_key = { lhs = Growth_Pressure$class$ value = 0.1 }
    }
}

Growth_ZoneHelper = {
    set_key = { lhs = Tmp_0 value = 0 }
    set_key = { lhs = Tmp_1 value = 0 }
    set_key = { lhs = Public_Tmp1 value = 0 }

    $scope$ = {
        limit = {
            isValidProv = yes
            [[flag] has_province_flag = $flag$ ]
            [[HRE] is_part_of_hre = yes
            OR = {
                culture_group = low_germanic
                culture_group = high_germanic
                culture_group = low_frankish
                culture_group = west_slavic
            }
            ]
            [[cultg] culture_group = $cultg$ ]
            [[cult] culture = $cult$ ]
        }
        set_key = { lhs = Tmp_0 value = 0 }
        set_key = { lhs = Tmp_1 value = 0 }

        [[SF]
        Growth_SetPressure = { class = SF labor = R peasant=yes }
        set_key = { lhs = Tmp_2 which = SF_Total }
        multiply_key = { lhs = Tmp_2 value = 0.5 }
        multiply_key = { lhs = Tmp_2 which = Growth_PressureSF }

		### Apply modifier on migration based on peasant freedom and tenacy reform
        #
        # Tenacy Reform Level     Peasant Freedom
        # ------------------- *  -----------------
        #          4                    100
        #
        # Constraints: [0.1, 1]
		owner = { 
		    set_key = { lhs = Tmp_8 which = Rights_NOTen }
		}

		set_key = { lhs = Tmp_8 which = owner }
		change_key = { lhs = Tmp_8 value = 3 } # move the reform key from the scale [-2,1] to [1,4]
		divide_key = { lhs = Tmp_8 value = 4 }

		set_key = { lhs = Tmp_9 which = SF_Freedom }

		divide_key = { lhs = Tmp_9 value = 100 } # move peasant freedom on a scale between [0,1]

		multiply_key = { lhs = Tmp_8 which = Tmp_9 } # calculate multiplier

		change_key = { lhs = Tmp_8 value = 0.1 }
		if = {
		    limit = {
		        check_key = { lhs = Tmp_8 value = 1.001 }
		    }
		    set_key = { lhs = Tmp_8 value = 1 }
		}
		else_if = {
		    limit = {
		        NOT = { check_key = { lhs = Tmp_8 value = 0.1 } }
		    }
		    set_key = { lhs = Tmp_8 value = 0.1 }
		}

		multiply_key = { lhs = Tmp_2 which = Tmp_8 } # apply multiplier to actual migrants pool

        change_key = { lhs = Tmp_0 which = Tmp_2 }

		set_key = { lhs = Tmp_9 which = SF_Total }
		multiply_key = { lhs = Tmp_9 which = Tmp_8 }
		change_key = { lhs = Tmp_1 which = Tmp_9 }
		]
        [[NM]
        Growth_SetPressure = { class = NM labor = NM nomad=yes }
        set_key = { lhs = Tmp_3 which = NM_Total }
        multiply_key = { lhs = Tmp_3 value = 0.5 }
        multiply_key = { lhs = Tmp_3 which = Growth_PressureNM }
        change_key = { lhs = Tmp_0 which = Tmp_3 }
		change_key = { lhs = Tmp_1 which = NM_Total }
        ]
        [[RE]
        Growth_SetPressure = { class = RE labor = UL urban=yes }
        set_key = { lhs = Tmp_4 which = RE_Total }
        multiply_key = { lhs = Tmp_4 value = 0.5 }
        multiply_key = { lhs = Tmp_4 which = Growth_PressureRE }
        change_key = { lhs = Tmp_0 which = Tmp_4 }
		change_key = { lhs = Tmp_1 which = RE_Total }
        ]
        [[NO]
        Growth_SetPressure = { class = NO labor = NO }
        set_key = { lhs = Tmp_5 which = NO_Total }
        multiply_key = { lhs = Tmp_5 value = 0.5 }
        multiply_key = { lhs = Tmp_5 which = Growth_PressureNO }
        change_key = { lhs = Tmp_0 which = Tmp_5 }
		change_key = { lhs = Tmp_1 which = NO_Total }
        ]
        [[BG]
        Growth_SetPressure = { class = BG labor = BG burgher=yes }
        set_key = { lhs = Tmp_6 which = BG_Total }
        multiply_key = { lhs = Tmp_6 value = 0.5 }
        multiply_key = { lhs = Tmp_6 which = Growth_PressureBG }
		change_key = { lhs = Tmp_1 which = BG_Total }
        change_key = { lhs = Tmp_0 which = Tmp_6 }
        ]
        [[CL]
        Growth_SetPressure = { class = CL labor = CL }
        set_key = { lhs = Tmp_7 which = CL_Total }
        multiply_key = { lhs = Tmp_7 value = 0.5 }
        multiply_key = { lhs = Tmp_7 which = Growth_PressureCL }
        change_key = { lhs = Tmp_0 which = Tmp_7 }
		change_key = { lhs = Tmp_1 which = CL_Total }
        ]
        multiply_key = { lhs = Tmp_1 value = 0.5 }
        
        PREV = {
            change_key = { lhs = Tmp_0 which = PREV }
            change_key = { lhs = Tmp_1 which = PREV }
        }
    }

    if = {
        limit = {
            check_key = { lhs = Tmp_0 value = 0.001 }
            check_key = { lhs = Tmp_1 value = 0.001 }
        }
        set_key = { lhs = Public_Tmp1 which = Tmp_0 }
        divide_key = { lhs = Public_Tmp1 which = Tmp_1 }
    }

    if = {
        limit = {
            check_key = { lhs = Public_Tmp1 value = 0.001 }
        }
        set_key = { lhs = Public_Tmp2 value = 0 }
        set_key = { lhs = Public_Tmp3 value = 0 }
        set_key = { lhs = Public_Tmp4 value = 0 }
        set_key = { lhs = Public_Tmp5 value = 0 }

        $scope$ = {
            limit = {
                isValidProv = yes
                [[flag]has_province_flag = $flag$]
                [[HRE]is_part_of_hre = yes
                OR = {
                    culture_group = low_germanic
                    culture_group = high_germanic
                    culture_group = low_frankish
                    culture_group = west_slavic
                }
                ]
                [[cultg]culture_group = $cultg$]
                [[cult]culture = $cult$]
            }
            set_key = { lhs = Public_Tmp1 which = PREV }
            set_key = { lhs = Public_Tmp2 value = 0 }
            set_key = { lhs = Public_Tmp3 value = 0 }
            set_key = { lhs = Public_Tmp4 value = 0 }
            set_key = { lhs = Public_Tmp5 value = 0 }

            [[SF] Growth_DoMove_HandleLocalMigration = { class = SF tmp = 2 zone=yes freedom = Tmp_8 }]
            [[NM] Growth_DoMove_HandleLocalMigration = { class = NM tmp = 3 zone=yes }]
            [[RE] Growth_DoMove_HandleLocalMigration = { class = RE tmp = 4 zone=yes }]
            [[NO] Growth_DoMove_HandleLocalMigration = { class = NO tmp = 5 zone=yes }]
            [[BG] Growth_DoMove_HandleLocalMigration = { class = BG tmp = 6 zone=yes factor = 2 }]
            [[CL] Growth_DoMove_HandleLocalMigration = { class = CL tmp = 7 zone=yes }]

            PREV = {
                change_key = { lhs = Public_Tmp2 which = PREV }
                change_key = { lhs = Public_Tmp3 which = PREV }
                change_key = { lhs = Public_Tmp4 which = PREV }
                change_key = { lhs = Public_Tmp5 which = PREV }
            }
        }

        if = {
            limit = {
                check_key = { lhs = Public_Tmp4 which = Public_Tmp5 }
            }
            set_key = { lhs = Public_Tmp4 which = Public_Tmp5 }
        }

        $scope$ = {
            limit = {
                isValidProv = yes
                [[flag]has_province_flag = $flag$]
                [[HRE]is_part_of_hre = yes
                OR = {
                    culture_group = low_germanic
                    culture_group = high_germanic
                    culture_group = low_frankish
                    culture_group = west_slavic
                }
                ]
                [[cultg]culture_group = $cultg$]
                [[cult]culture = $cult$]
            }
            set_key = { lhs = Public_Tmp2 which = PREV }
            set_key = { lhs = Public_Tmp3 which = PREV }
            set_key = { lhs = Public_Tmp4 which = PREV }

            [[SF]Growth_DoMove_DistributeMigration = { class = SF tmp = 2 }]
            [[NM]Growth_DoMove_DistributeMigration = { class = NM tmp = 3 }]
            [[RE]Growth_DoMove_DistributeMigration = { class = RE tmp = 4 }]
            [[NO]Growth_DoMove_DistributeMigration = { class = NO tmp = 5 }]
            [[BG]Growth_DoMove_DistributeMigration = { class = BG tmp = 6 }]
            [[CL]Growth_DoMove_DistributeMigration = { class = CL tmp = 7 }]

            set_key = { lhs = Public_Tmp1 value = 0 }
            set_key = { lhs = Public_Tmp2 value = 0 }
            set_key = { lhs = Public_Tmp3 value = 0 }
            set_key = { lhs = Public_Tmp4 value = 0 }
            set_key = { lhs = Public_Tmp5 value = 0 }
            set_key = { lhs = Public_Tmp9 value = 0 }
        }

        set_key = { lhs = Public_Tmp2 value = 0 }
        set_key = { lhs = Public_Tmp3 value = 0 }
        set_key = { lhs = Public_Tmp4 value = 0 }
        set_key = { lhs = Public_Tmp5 value = 0 }
    }

    set_key = { lhs = Tmp_0 value = 0 }
    set_key = { lhs = Tmp_1 value = 0 }

    set_key = { lhs = Public_Tmp1 value = 0 }
}
